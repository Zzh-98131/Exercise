<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>标题不能是力扣算法题</title>
</head>
<body>
  <script type="text/javascript" charset="utf-8">
    /**
     * 题目描述
     * url：https://leetcode-cn.com/problems/
     */ 
     var functionName = function(params) {
      
    };

    /**
     * 题目描述:给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。
     * url：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2y0c2/
     */ 
     var intersect = function(nums1, nums2) {
      let min = nums2, max = nums1, res = []
      if (nums1.length < nums2.length) {
        min = nums1
        max = nums2
      }
      for (let i = 0; i < min.length; ++i) {
        if (max.indexOf(min[i]) > -1) {
          max[max.indexOf(min[i])] = null
          res.push(min[i])
        }
      }
      return res
    };
    console.log(intersect([4,9,5], [9,4,9,8,4]))

    /**
     * 题目描述:给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
     * url：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x21ib6/
     */ 
     var singleNumber = function(nums) {
      for (let i = 0; i < nums.length; ++i) {
        if (nums[i] != null) {
          let oneTime = nums[i]
          nums[i] = null
          if (nums.indexOf(oneTime) == -1) {
            return oneTime
          } else {
            nums[nums.indexOf(oneTime)] = null
          }
        }
      }
    };
    // console.log(singleNumber([2,2,1]))

    /**
     * 题目描述:给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。
     * url：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x248f5/
     */ 
     var containsDuplicate = function(nums) {
      return Array.from(new Set(nums)).length != nums.length
    };
    // console.log(containsDuplicate([1,2,3,4]))

    /**
     * 题目描述:给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数
     * 要求直接改变原数组，方法不需要返回
     * url：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2skh7/
     */ 
     var rotate = function(nums, k) {
      let len = nums.length, arr = new Array(len)
      for (let i = 0; i < len; ++i) {
        arr[(i + k) % len] = nums[i]
      }
      for (let i = 0; i < len; ++i) {
        nums[i] = arr[i]
      }
    };
    // let a = [1,2,3,4,5,6,7]
    // rotate(a, 3)
    // console.log(a)

    /**
     * 题目描述:给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。
     * 由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。
     * 不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
     * url：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/
     */ 
     var removeDuplicates = function(nums) {
      // 使用快慢指针解题
      if (nums.length == 0) {
        return 0
      } else if (nums.length == 1) {
        return 1
      } else {
        let slow = 1 // 从下标1开始
        for (let fast = 1; fast < nums.length; fast++) { // 快指针代表当前遍历下标
          if (nums[fast] != nums[fast - 1]) {
            nums[slow] = nums[fast]
            slow++
          }
        }
        return slow
      }
    };
    // console.log(removeDuplicates([0,0,1,1,1,2,2,3,3,4]))

    /**
     * 买卖股票的最佳时机:给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。
     * 在每一天，你可能会决定购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以购买它，然后在 同一天 出售。
     * 返回 你能获得的 最大 利润 。
     * url：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2zsx1/
     */ 
     var maxProfit = function(prices) {
      let keep = false, // 当前是否持有股票
          inPrice = 0, outPrice = 0, // 记录买入卖出价
          profit = 0 // 利润
      for (let i = 0; i < prices.length; i++) {
        let diff = prices[i + 1] - prices[i] > 0
        if (diff && !keep) { // 当趋势上升，手里又没有股票
          inPrice = prices[i]
          console.log(`在第${i+1}天以${inPrice}买入`)
          keep = true
        }
        if ((!diff || (i + 1 == prices.length)) && keep) {
          outPrice = prices[i]
          profit += outPrice - inPrice
          console.log(`在第${i+1}天以${outPrice}卖出，当前收益${profit}`)
          keep = false
        }
      }
      return profit
    };
    // console.log(maxProfit([7,6,4,3,1]))

    /**
     * 最大单词长度乘积，给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。
     * 你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。
     * url：https://leetcode-cn.com/problems/maximum-product-of-word-lengths/
     */ 
     var maxProduct = function(words) {
      words =  words.sort((a, b) => {
        return b.length - a.length
      })
      let ans = [0]
      let hasSameWord = function (long, short) {
        let res = false
        short = new Set(short.split(''))
        for (let i of short) { // 使用for of可以中途跳出循环，forEach则不行
          if (long.includes(i)) {
            res = true
            break
          }
        }
        return res
      }
      for (let i = 0; i < words.length; i++) {
        for (let j = i + 1; j < words.length; j++) {
          if (hasSameWord(words[i], words[j])) {
            continue
          } else {
            ans.push(words[i].length * words[j].length)
          }
        }
      }
      return Math.max(...ans)
    };

    // 下面是更优解
    // var maxProduct = function(words) {
    //   const map = new Map();
    //   let ans = 0;
    //   for(const word of words){
    //       const h = hash(word), n = word.length;
    //       if(map.has(h) && map.get(h) >= n)
    //           continue;
    //       for(const other of map.keys())
    //           if((other & h) == 0)
    //               ans = Math.max(ans, map.get(other) * n);
    //       map.set(h, n);
    //   }
    //   return ans;
    // };
    // var hash = function(word) {
    //   let res = 0;
    //   for(let i=0;i<word.length;i++)
    //       res |= 1 << (word[i].charCodeAt() - 'a'.charCodeAt());
    //   return res;
    // };
    // console.log(maxProduct(["a","ab","abc","d","cd","bcd","abcd"]))

    /**
     * 替换字符串中的括号内容
     * url：https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string/
     */ 
    var evaluate = function(s, knowledge) {
      let sArr = [], a = s.split('(')
      .map(str => {
        return str.split(')')
      })
      .forEach(str => {
        sArr = sArr.concat(...str)
      })
      sArr.map((str, index) => {
        if (index % 2 === 1) {
          let key = knowledge.filter(e => {
            return e[0] == str
          })
          if (key.length) {
            sArr[index] = key[0][1]
          } else {
            sArr[index] = '?'
          }
        }
      })
      return sArr.join('')

      // 更优解法
      const map = Object.fromEntries(knowledge);
	    const reg = /\(([a-z]+)\)/g;
	    return s.replace(reg,(input,$1)=>map[$1] || '?');
    };
    // console.log(evaluate('(a)(b)', [["a","b"],["b","a"]]))

    /**
     * 提莫攻击，给一个数组和持续时间，数组中数字代表发起攻击的时间点，发起攻击后中毒状态会持续一段时间，其中遇到新的攻击会重置持续时间，返回最终中毒状态的时长
     * url：https://leetcode-cn.com/problems/teemo-attacking/
     */ 
     var findPoisonedDuration = function (timeSeries, duration) {
      let lastTime = 0, endTime = timeSeries[0] + duration - 1
      for (let i = 1; i < timeSeries.length; i++) {
        if (timeSeries[i] <= endTime) {
          lastTime += timeSeries[i] - timeSeries[i - 1]
          endTime = timeSeries[i] + duration - 1
        } else {
          lastTime += duration
          endTime = timeSeries[i] + duration - 1
        }
      }
      lastTime += duration
      return lastTime
    }
    // console.log(findPoisonedDuration([1, 4], 2))

    /**
     * 删除排序数组中的重复项，原地修改输入数组，并在使用O(1)额外空间的条件下完成
     * url：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/
     */ 
    var removeDuplicates = function (nums) {
      let i = 1
      while (i < nums.length) {
        if (nums[i] === nums[i - 1]) {
          nums.splice(i, 1)
          continue
        } else {
          i++
        }
      }
      return nums.length
    }
    // console.log(removeDuplicates([0,0,1,1,1,2,2,3,3,4]))

    /**
     * 买卖股票的最佳时机，给定一个数组，元素是该股票当日价格，每天只能买或卖，尽可能通过多次买卖，获得最大利润
     * url：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2zsx1/
     */ 
    var stockPriceMax = function (prices) {
      let max = Math.max(...prices), min = Math.min(...prices)
    }
    // stockPriceMax([7,1,5,3,6,4])

    /**
     * 给定一个整数数组nums和一个整数目标值 target，请你在该数组中找出和为目标值target的那两个整数，并返回它们的数组下标。
     * 例：[3,2,4] 6 => [1,2]
     * url: https://leetcode-cn.com/problems/two-sum/submissions/
     */ 
    var twoSum = function(nums, target) {
    }

    /**
     * 给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false
     * url: https://leetcode-cn.com/problems/power-of-four/
     */
    var isPowerOfFour = function(n) {
      let binary = n.toString(2)
      let regular = /^1(00)*$/
      return regular.test(binary)
    }

    /**
     * 找出所有子集的异或总和再求和
     * 异或逻辑运算（XOR）相同为0，不同为1
     * https://leetcode-cn.com/problems/sum-of-all-subset-xor-totals/
     */ 
    var subsetXORSum = function(nums) {
      // 0  1    2          3                          4
      // 0  0/1  0/1/2/1,2  0/1/2/3/1,2/1,3/2,3/1,2,3  0/1/2/3/4/1,2/1,3/1,4/2,3/2,4/3,4/1,2,3/1,2,4/1,3,4/2,3,4/1,2,3,4
      // 1  2    4          8                          16
      let len = Math.pow(2, nums.length)
      let sum = 0
      for (let i = 0; i < len; i++) {
        let arr = new Array(nums.length)
        let nArr = []
        i.toString(2).split('').map(e => {
          arr.shift()
          arr.push(e)
        })
        arr.map((e, index) => {
          if (e && e === '1') {
            nArr.push(nums[index])
          }
        })
        if (nArr.length) {
          sum += nArr.reduce((a, b) => {
          return a ^ b
        })
        }
      }
      return sum
    };

    /**
     * 某乐团的演出场地可视作 num * num 的二维矩阵 grid（左上角坐标为 [0,0])，每个位置站有一位成员。乐团共有 9 种乐器，乐器编号为 1~9，每位成员持有 1 个乐器。
     * y+
     * x+
     * y-
     * x-
     * 暴力模拟算法，但不适用于数据量过大时的情况
     * https://leetcode-cn.com/problems/SNJvJP
     */
    var orchestraLayout = function(num, xPos, yPos) {
      let twoDArr = new Array(num)
      for (let i = 0; i < num; i++) {
        twoDArr[i] = new Array(num)
      }
      let xP = 0, // x坐标
          yP = 0, // y坐标
          operate = [
            [false, true],
            [true, true],
            [false, false],
            [true, false]
          ],
          count = 1,
          oInd = 0,
          value = 1 // 值
      while (count <= num * num) {
        if (oInd > 3) {
          oInd = 0
        }
        switch (oInd) {
          case 0: // y+
            twoDArr[xP][yP] = value
            count++
            if (yP + 1 < num && !twoDArr[xP][yP + 1]) {
              yP += 1
            } else {
              xP++
              oInd++
            }
            value + 1 > 9 ? value = 1 : value += 1
            break
          case 1: // x+
            twoDArr[xP][yP] = value
            count++
            if (xP + 1 < num && !twoDArr[xP + 1][yP]) {
              xP += 1
            } else {
              yP--
              oInd++
            }
            value + 1 > 9 ? value = 1 : value += 1
            break
          case 2: // y-
            twoDArr[xP][yP] = value
            count++
            if (yP - 1 >= 0 && !twoDArr[xP][yP - 1]) {
              yP -= 1
            } else {
              xP--
              oInd++
            }
            value + 1 > 9 ? value = 1 : value += 1
            break
          case 3: // x-
            twoDArr[xP][yP] = value
            count++
            if (xP - 1 >= 0 && !twoDArr[xP - 1][yP]) {
              xP -= 1
            } else {
              yP++
              oInd++
            }
            value + 1 > 9 ? value = 1 : value += 1
            break
          default: break
        }
      }
      return twoDArr
    };

    /**
     * 某乐团的演出场地可视作 num * num 的二维矩阵 grid（左上角坐标为 [0,0])，每个位置站有一位成员。乐团共有 9 种乐器，乐器编号为 1~9，每位成员持有 1 个乐器。
     * 层层剥洋葱算法
     * https://leetcode-cn.com/problems/SNJvJP
     */
    var orchestraLayoutV2 = function(num, xPos, yPos) {
      let x = xPos + 1
          y = yPos + 1,
          distance = new Map([
            [num - y, 'right'],
            [yPos, 'left'],
            [num - x, 'down'],
            [xPos, 'up']
          ])
          min = Math.min(xPos, num - y, num - x, yPos)
          closeTo = distance.get(min)
          nums = 0,
          result = 0
      for (let i = 0; i < min; i++) {
        nums += (num - i * 2) * 4 - 4
      }
      switch(closeTo) {
        case 'up':
          nums += y - min
          break
        case 'right':
          nums += num - min * 3 + x - 1
          break
        case 'down':
          nums += num * 3 - min * 5 - 1 - y
          break
        case 'left':
          nums += num * 4 - min * 7 - 2 - x
          break
        default: break
      }
      result = nums % 9 === 0 ? 9 : nums % 9
      return result
    };

    /**
     * 给一个山脉数组，找出顶峰坐标
     * 直接循环法，时间复杂度O(n)
     * https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/
     */ 
    var peakIndexInMountainArray = function(arr) {
      let result = 0
      arr.map((e, index) => {
        if (arr[index - 1] !== undefined && arr[index + 1] !== undefined && arr[index - 1] < e && arr[index + 1] < e) {
          result = index
        }
      })
      return result
    };

    /**
     * 给一个山脉数组，找出顶峰坐标
     * 进阶法：二分查找，直接判断arr[mid]与arr[mid + 1]的大小，就能知道峰顶在mid哪一边
     * https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/
     */ 
     var peakIndexInMountainArrayV2 = function(arr) {
      let brr = arr
      while (brr.length !== 2) {
        let mid = brr.length % 2 === 0 ? brr.length / 2 - 1 : (brr.length + 1) / 2 - 1
        if (brr[mid + 1] < brr[mid]) {
          brr = brr.slice(0, mid + 1)
        } else {
          brr = brr.slice(mid, brr.length)
        }
        console.log(brr, mid)
      }
      return arr.indexOf(Math.max(...brr))
    };

    /**
     * 877. 石子游戏，偶数堆石子，每次只能从头尾拿，谁最后拿到最多。石子总数奇数
     * https://leetcode-cn.com/problems/stone-game/
     */
     var stoneGame = function(piles) {

    };

    /**
     * 7. 整数反转。给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
     * 如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。
     * https://leetcode-cn.com/problems/reverse-integer/
     */ 
     var reverse = function(x) {
      let regular = /^(\+|\-)/.test(x.toString()), result = null
      if (regular) {
          result = x.toString().split('')[0] + x.toString().split('').slice(1).reverse().join('')
      } else {
          result =  x.toString().split('').reverse().join('')
      }
      if (result < -Math.pow(2, 31) || result > Math.pow(2, 31) - 1) {
          return '0'
      } else {
          return result
      }
    };
  </script>
</body>
</html>